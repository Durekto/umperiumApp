{"ast":null,"code":"import { p as pointerCoord } from './helpers-46f4a262.js';\nvar cloneMap = new WeakMap();\n\nvar relocateInput = function (componentEl, inputEl, shouldRelocate, inputRelativeY) {\n  if (inputRelativeY === void 0) {\n    inputRelativeY = 0;\n  }\n\n  if (cloneMap.has(componentEl) === shouldRelocate) {\n    return;\n  }\n\n  if (shouldRelocate) {\n    addClone(componentEl, inputEl, inputRelativeY);\n  } else {\n    removeClone(componentEl, inputEl);\n  }\n};\n\nvar isFocused = function (input) {\n  return input === input.getRootNode().activeElement;\n};\n\nvar addClone = function (componentEl, inputEl, inputRelativeY) {\n  // this allows for the actual input to receive the focus from\n  // the user's touch event, but before it receives focus, it\n  // moves the actual input to a location that will not screw\n  // up the app's layout, and does not allow the native browser\n  // to attempt to scroll the input into place (messing up headers/footers)\n  // the cloned input fills the area of where native input should be\n  // while the native input fakes out the browser by relocating itself\n  // before it receives the actual focus event\n  // We hide the focused input (with the visible caret) invisible by making it scale(0),\n  var parentEl = inputEl.parentNode; // DOM WRITES\n\n  var clonedEl = inputEl.cloneNode(false);\n  clonedEl.classList.add('cloned-input');\n  clonedEl.tabIndex = -1;\n  parentEl.appendChild(clonedEl);\n  cloneMap.set(componentEl, clonedEl);\n  var doc = componentEl.ownerDocument;\n  var tx = doc.dir === 'rtl' ? 9999 : -9999;\n  componentEl.style.pointerEvents = 'none';\n  inputEl.style.transform = \"translate3d(\" + tx + \"px,\" + inputRelativeY + \"px,0) scale(0)\";\n};\n\nvar removeClone = function (componentEl, inputEl) {\n  var clone = cloneMap.get(componentEl);\n\n  if (clone) {\n    cloneMap.delete(componentEl);\n    clone.remove();\n  }\n\n  componentEl.style.pointerEvents = '';\n  inputEl.style.transform = '';\n};\n\nvar enableHideCaretOnScroll = function (componentEl, inputEl, scrollEl) {\n  if (!scrollEl || !inputEl) {\n    return function () {\n      return;\n    };\n  }\n\n  var scrollHideCaret = function (shouldHideCaret) {\n    if (isFocused(inputEl)) {\n      relocateInput(componentEl, inputEl, shouldHideCaret);\n    }\n  };\n\n  var onBlur = function () {\n    return relocateInput(componentEl, inputEl, false);\n  };\n\n  var hideCaret = function () {\n    return scrollHideCaret(true);\n  };\n\n  var showCaret = function () {\n    return scrollHideCaret(false);\n  };\n\n  scrollEl.addEventListener('ionScrollStart', hideCaret);\n  scrollEl.addEventListener('ionScrollEnd', showCaret);\n  inputEl.addEventListener('blur', onBlur);\n  return function () {\n    scrollEl.removeEventListener('ionScrollStart', hideCaret);\n    scrollEl.removeEventListener('ionScrollEnd', showCaret);\n    inputEl.addEventListener('ionBlur', onBlur);\n  };\n};\n\nvar SKIP_SELECTOR = 'input, textarea, [no-blur]';\n\nvar enableInputBlurring = function () {\n  var focused = true;\n  var didScroll = false;\n  var doc = document;\n\n  var onScroll = function () {\n    didScroll = true;\n  };\n\n  var onFocusin = function () {\n    focused = true;\n  };\n\n  var onTouchend = function (ev) {\n    // if app did scroll return early\n    if (didScroll) {\n      didScroll = false;\n      return;\n    }\n\n    var active = doc.activeElement;\n\n    if (!active) {\n      return;\n    } // only blur if the active element is a text-input or a textarea\n\n\n    if (active.matches(SKIP_SELECTOR)) {\n      return;\n    } // if the selected target is the active element, do not blur\n\n\n    var tapped = ev.target;\n\n    if (tapped === active) {\n      return;\n    }\n\n    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n      return;\n    }\n\n    focused = false; // TODO: find a better way, why 50ms?\n\n    setTimeout(function () {\n      if (!focused) {\n        active.blur();\n      }\n    }, 50);\n  };\n\n  doc.addEventListener('ionScrollStart', onScroll);\n  doc.addEventListener('focusin', onFocusin, true);\n  doc.addEventListener('touchend', onTouchend, false);\n  return function () {\n    doc.removeEventListener('ionScrollStart', onScroll, true);\n    doc.removeEventListener('focusin', onFocusin, true);\n    doc.removeEventListener('touchend', onTouchend, false);\n  };\n};\n\nvar SCROLL_ASSIST_SPEED = 0.3;\n\nvar getScrollData = function (componentEl, contentEl, keyboardHeight) {\n  var itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\n  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\n};\n\nvar calcScrollData = function (inputRect, contentRect, keyboardHeight, platformHeight) {\n  // compute input's Y values relative to the body\n  var inputTop = inputRect.top;\n  var inputBottom = inputRect.bottom; // compute visible area\n\n  var visibleAreaTop = contentRect.top;\n  var visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight); // compute safe area\n\n  var safeAreaTop = visibleAreaTop + 15;\n  var safeAreaBottom = visibleAreaBottom * 0.5; // figure out if each edge of the input is within the safe area\n\n  var distanceToBottom = safeAreaBottom - inputBottom;\n  var distanceToTop = safeAreaTop - inputTop; // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n\n  var desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0); // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n  // gets focus, so make sure we don't scroll the input above the visible area\n\n  var scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n  var distance = Math.abs(scrollAmount);\n  var duration = distance / SCROLL_ASSIST_SPEED;\n  var scrollDuration = Math.min(400, Math.max(150, duration));\n  return {\n    scrollAmount: scrollAmount,\n    scrollDuration: scrollDuration,\n    scrollPadding: keyboardHeight,\n    inputSafeY: -(inputTop - safeAreaTop) + 4\n  };\n};\n\nvar enableScrollAssist = function (componentEl, inputEl, contentEl, keyboardHeight) {\n  var coord;\n\n  var touchStart = function (ev) {\n    coord = pointerCoord(ev);\n  };\n\n  var touchEnd = function (ev) {\n    // input cover touchend/mouseup\n    if (!coord) {\n      return;\n    } // get where the touchend/mouseup ended\n\n\n    var endCoord = pointerCoord(ev); // focus this input if the pointer hasn't moved XX pixels\n    // and the input doesn't already have focus\n\n    if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\n      ev.preventDefault();\n      ev.stopPropagation(); // begin the input focus process\n\n      jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight);\n    }\n  };\n\n  componentEl.addEventListener('touchstart', touchStart, true);\n  componentEl.addEventListener('touchend', touchEnd, true);\n  return function () {\n    componentEl.removeEventListener('touchstart', touchStart, true);\n    componentEl.removeEventListener('touchend', touchEnd, true);\n  };\n};\n\nvar jsSetFocus = function (componentEl, inputEl, contentEl, keyboardHeight) {\n  var scrollData = getScrollData(componentEl, contentEl, keyboardHeight);\n\n  if (Math.abs(scrollData.scrollAmount) < 4) {\n    // the text input is in a safe position that doesn't\n    // require it to be scrolled into view, just set focus now\n    inputEl.focus();\n    return;\n  } // temporarily move the focus to the focus holder so the browser\n  // doesn't freak out while it's trying to get the input in place\n  // at this point the native text input still does not have focus\n\n\n  relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\n  inputEl.focus(); // scroll the input into place\n\n  contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration).then(function () {\n    // the scroll view is in the correct position now\n    // give the native text input focus\n    relocateInput(componentEl, inputEl, false, scrollData.inputSafeY); // ensure this is the focused input\n\n    inputEl.focus();\n  });\n};\n\nvar hasPointerMoved = function (threshold, startCoord, endCoord) {\n  if (startCoord && endCoord) {\n    var deltaX = startCoord.x - endCoord.x;\n    var deltaY = startCoord.y - endCoord.y;\n    var distance = deltaX * deltaX + deltaY * deltaY;\n    return distance > threshold * threshold;\n  }\n\n  return false;\n};\n\nvar PADDING_TIMER_KEY = '$ionPaddingTimer';\n\nvar enableScrollPadding = function (keyboardHeight) {\n  var doc = document;\n\n  var onFocusin = function (ev) {\n    setScrollPadding(ev.target, keyboardHeight);\n  };\n\n  var onFocusout = function (ev) {\n    setScrollPadding(ev.target, 0);\n  };\n\n  doc.addEventListener('focusin', onFocusin);\n  doc.addEventListener('focusout', onFocusout);\n  return function () {\n    doc.removeEventListener('focusin', onFocusin);\n    doc.removeEventListener('focusout', onFocusout);\n  };\n};\n\nvar setScrollPadding = function (input, keyboardHeight) {\n  if (input.tagName !== 'INPUT') {\n    return;\n  }\n\n  if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\n    return;\n  }\n\n  if (input.parentElement && input.parentElement.parentElement && input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\n    return;\n  }\n\n  var el = input.closest('ion-content');\n\n  if (el === null) {\n    return;\n  }\n\n  var timer = el[PADDING_TIMER_KEY];\n\n  if (timer) {\n    clearTimeout(timer);\n  }\n\n  if (keyboardHeight > 0) {\n    el.style.setProperty('--keyboard-offset', keyboardHeight + \"px\");\n  } else {\n    el[PADDING_TIMER_KEY] = setTimeout(function () {\n      el.style.setProperty('--keyboard-offset', '0px');\n    }, 120);\n  }\n};\n\nvar INPUT_BLURRING = true;\nvar SCROLL_PADDING = true;\n\nvar startInputShims = function (config) {\n  var doc = document;\n  var keyboardHeight = config.getNumber('keyboardHeight', 290);\n  var scrollAssist = config.getBoolean('scrollAssist', true);\n  var hideCaret = config.getBoolean('hideCaretOnScroll', true);\n  var inputBlurring = config.getBoolean('inputBlurring', true);\n  var scrollPadding = config.getBoolean('scrollPadding', true);\n  var inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\n  var hideCaretMap = new WeakMap();\n  var scrollAssistMap = new WeakMap();\n\n  var registerInput = function (componentEl) {\n    var inputEl = (componentEl.shadowRoot || componentEl).querySelector('input') || (componentEl.shadowRoot || componentEl).querySelector('textarea');\n    var scrollEl = componentEl.closest('ion-content');\n\n    if (!inputEl) {\n      return;\n    }\n\n    if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n      var rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n      hideCaretMap.set(componentEl, rmFn);\n    }\n\n    if (!!scrollEl && scrollAssist && !scrollAssistMap.has(componentEl)) {\n      var rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, keyboardHeight);\n      scrollAssistMap.set(componentEl, rmFn);\n    }\n  };\n\n  var unregisterInput = function (componentEl) {\n    if (hideCaret) {\n      var fn = hideCaretMap.get(componentEl);\n\n      if (fn) {\n        fn();\n      }\n\n      hideCaretMap.delete(componentEl);\n    }\n\n    if (scrollAssist) {\n      var fn = scrollAssistMap.get(componentEl);\n\n      if (fn) {\n        fn();\n      }\n\n      scrollAssistMap.delete(componentEl);\n    }\n  };\n\n  if (inputBlurring && INPUT_BLURRING) {\n    enableInputBlurring();\n  }\n\n  if (scrollPadding && SCROLL_PADDING) {\n    enableScrollPadding(keyboardHeight);\n  } // Input might be already loaded in the DOM before ion-device-hacks did.\n  // At this point we need to look for all of the inputs not registered yet\n  // and register them.\n\n\n  for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n    var input = inputs_1[_i];\n    registerInput(input);\n  }\n\n  doc.addEventListener('ionInputDidLoad', function (ev) {\n    registerInput(ev.detail);\n  });\n  doc.addEventListener('ionInputDidUnload', function (ev) {\n    unregisterInput(ev.detail);\n  });\n};\n\nexport { startInputShims };","map":{"version":3,"sources":["D:/Work/Projects/umperiumApp/react-ionic/node_modules/@ionic/core/dist/esm-es5/input-shims-a4fc53ac.js"],"names":["p","pointerCoord","cloneMap","WeakMap","relocateInput","componentEl","inputEl","shouldRelocate","inputRelativeY","has","addClone","removeClone","isFocused","input","getRootNode","activeElement","parentEl","parentNode","clonedEl","cloneNode","classList","add","tabIndex","appendChild","set","doc","ownerDocument","tx","dir","style","pointerEvents","transform","clone","get","delete","remove","enableHideCaretOnScroll","scrollEl","scrollHideCaret","shouldHideCaret","onBlur","hideCaret","showCaret","addEventListener","removeEventListener","SKIP_SELECTOR","enableInputBlurring","focused","didScroll","document","onScroll","onFocusin","onTouchend","ev","active","matches","tapped","target","closest","setTimeout","blur","SCROLL_ASSIST_SPEED","getScrollData","contentEl","keyboardHeight","itemEl","calcScrollData","getBoundingClientRect","defaultView","innerHeight","inputRect","contentRect","platformHeight","inputTop","top","inputBottom","bottom","visibleAreaTop","visibleAreaBottom","Math","min","safeAreaTop","safeAreaBottom","distanceToBottom","distanceToTop","desiredScrollAmount","round","scrollAmount","distance","abs","duration","scrollDuration","max","scrollPadding","inputSafeY","enableScrollAssist","coord","touchStart","touchEnd","endCoord","hasPointerMoved","preventDefault","stopPropagation","jsSetFocus","scrollData","focus","scrollByPoint","then","threshold","startCoord","deltaX","x","deltaY","y","PADDING_TIMER_KEY","enableScrollPadding","setScrollPadding","onFocusout","tagName","parentElement","el","timer","clearTimeout","setProperty","INPUT_BLURRING","SCROLL_PADDING","startInputShims","config","getNumber","scrollAssist","getBoolean","inputBlurring","inputs","Array","from","querySelectorAll","hideCaretMap","scrollAssistMap","registerInput","shadowRoot","querySelector","rmFn","unregisterInput","fn","_i","inputs_1","length","detail"],"mappings":"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","sourcesContent":["import { p as pointerCoord } from './helpers-46f4a262.js';\r\nvar cloneMap = new WeakMap();\r\nvar relocateInput = function (componentEl, inputEl, shouldRelocate, inputRelativeY) {\r\n    if (inputRelativeY === void 0) { inputRelativeY = 0; }\r\n    if (cloneMap.has(componentEl) === shouldRelocate) {\r\n        return;\r\n    }\r\n    if (shouldRelocate) {\r\n        addClone(componentEl, inputEl, inputRelativeY);\r\n    }\r\n    else {\r\n        removeClone(componentEl, inputEl);\r\n    }\r\n};\r\nvar isFocused = function (input) {\r\n    return input === input.getRootNode().activeElement;\r\n};\r\nvar addClone = function (componentEl, inputEl, inputRelativeY) {\r\n    // this allows for the actual input to receive the focus from\r\n    // the user's touch event, but before it receives focus, it\r\n    // moves the actual input to a location that will not screw\r\n    // up the app's layout, and does not allow the native browser\r\n    // to attempt to scroll the input into place (messing up headers/footers)\r\n    // the cloned input fills the area of where native input should be\r\n    // while the native input fakes out the browser by relocating itself\r\n    // before it receives the actual focus event\r\n    // We hide the focused input (with the visible caret) invisible by making it scale(0),\r\n    var parentEl = inputEl.parentNode;\r\n    // DOM WRITES\r\n    var clonedEl = inputEl.cloneNode(false);\r\n    clonedEl.classList.add('cloned-input');\r\n    clonedEl.tabIndex = -1;\r\n    parentEl.appendChild(clonedEl);\r\n    cloneMap.set(componentEl, clonedEl);\r\n    var doc = componentEl.ownerDocument;\r\n    var tx = doc.dir === 'rtl' ? 9999 : -9999;\r\n    componentEl.style.pointerEvents = 'none';\r\n    inputEl.style.transform = \"translate3d(\" + tx + \"px,\" + inputRelativeY + \"px,0) scale(0)\";\r\n};\r\nvar removeClone = function (componentEl, inputEl) {\r\n    var clone = cloneMap.get(componentEl);\r\n    if (clone) {\r\n        cloneMap.delete(componentEl);\r\n        clone.remove();\r\n    }\r\n    componentEl.style.pointerEvents = '';\r\n    inputEl.style.transform = '';\r\n};\r\nvar enableHideCaretOnScroll = function (componentEl, inputEl, scrollEl) {\r\n    if (!scrollEl || !inputEl) {\r\n        return function () { return; };\r\n    }\r\n    var scrollHideCaret = function (shouldHideCaret) {\r\n        if (isFocused(inputEl)) {\r\n            relocateInput(componentEl, inputEl, shouldHideCaret);\r\n        }\r\n    };\r\n    var onBlur = function () { return relocateInput(componentEl, inputEl, false); };\r\n    var hideCaret = function () { return scrollHideCaret(true); };\r\n    var showCaret = function () { return scrollHideCaret(false); };\r\n    scrollEl.addEventListener('ionScrollStart', hideCaret);\r\n    scrollEl.addEventListener('ionScrollEnd', showCaret);\r\n    inputEl.addEventListener('blur', onBlur);\r\n    return function () {\r\n        scrollEl.removeEventListener('ionScrollStart', hideCaret);\r\n        scrollEl.removeEventListener('ionScrollEnd', showCaret);\r\n        inputEl.addEventListener('ionBlur', onBlur);\r\n    };\r\n};\r\nvar SKIP_SELECTOR = 'input, textarea, [no-blur]';\r\nvar enableInputBlurring = function () {\r\n    var focused = true;\r\n    var didScroll = false;\r\n    var doc = document;\r\n    var onScroll = function () {\r\n        didScroll = true;\r\n    };\r\n    var onFocusin = function () {\r\n        focused = true;\r\n    };\r\n    var onTouchend = function (ev) {\r\n        // if app did scroll return early\r\n        if (didScroll) {\r\n            didScroll = false;\r\n            return;\r\n        }\r\n        var active = doc.activeElement;\r\n        if (!active) {\r\n            return;\r\n        }\r\n        // only blur if the active element is a text-input or a textarea\r\n        if (active.matches(SKIP_SELECTOR)) {\r\n            return;\r\n        }\r\n        // if the selected target is the active element, do not blur\r\n        var tapped = ev.target;\r\n        if (tapped === active) {\r\n            return;\r\n        }\r\n        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\r\n            return;\r\n        }\r\n        focused = false;\r\n        // TODO: find a better way, why 50ms?\r\n        setTimeout(function () {\r\n            if (!focused) {\r\n                active.blur();\r\n            }\r\n        }, 50);\r\n    };\r\n    doc.addEventListener('ionScrollStart', onScroll);\r\n    doc.addEventListener('focusin', onFocusin, true);\r\n    doc.addEventListener('touchend', onTouchend, false);\r\n    return function () {\r\n        doc.removeEventListener('ionScrollStart', onScroll, true);\r\n        doc.removeEventListener('focusin', onFocusin, true);\r\n        doc.removeEventListener('touchend', onTouchend, false);\r\n    };\r\n};\r\nvar SCROLL_ASSIST_SPEED = 0.3;\r\nvar getScrollData = function (componentEl, contentEl, keyboardHeight) {\r\n    var itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\r\n    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\r\n};\r\nvar calcScrollData = function (inputRect, contentRect, keyboardHeight, platformHeight) {\r\n    // compute input's Y values relative to the body\r\n    var inputTop = inputRect.top;\r\n    var inputBottom = inputRect.bottom;\r\n    // compute visible area\r\n    var visibleAreaTop = contentRect.top;\r\n    var visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\r\n    // compute safe area\r\n    var safeAreaTop = visibleAreaTop + 15;\r\n    var safeAreaBottom = visibleAreaBottom * 0.5;\r\n    // figure out if each edge of the input is within the safe area\r\n    var distanceToBottom = safeAreaBottom - inputBottom;\r\n    var distanceToTop = safeAreaTop - inputTop;\r\n    // desiredScrollAmount is the negated distance to the safe area according to our calculations.\r\n    var desiredScrollAmount = Math.round((distanceToBottom < 0)\r\n        ? -distanceToBottom\r\n        : (distanceToTop > 0)\r\n            ? -distanceToTop\r\n            : 0);\r\n    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\r\n    // gets focus, so make sure we don't scroll the input above the visible area\r\n    var scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\r\n    var distance = Math.abs(scrollAmount);\r\n    var duration = distance / SCROLL_ASSIST_SPEED;\r\n    var scrollDuration = Math.min(400, Math.max(150, duration));\r\n    return {\r\n        scrollAmount: scrollAmount,\r\n        scrollDuration: scrollDuration,\r\n        scrollPadding: keyboardHeight,\r\n        inputSafeY: -(inputTop - safeAreaTop) + 4\r\n    };\r\n};\r\nvar enableScrollAssist = function (componentEl, inputEl, contentEl, keyboardHeight) {\r\n    var coord;\r\n    var touchStart = function (ev) {\r\n        coord = pointerCoord(ev);\r\n    };\r\n    var touchEnd = function (ev) {\r\n        // input cover touchend/mouseup\r\n        if (!coord) {\r\n            return;\r\n        }\r\n        // get where the touchend/mouseup ended\r\n        var endCoord = pointerCoord(ev);\r\n        // focus this input if the pointer hasn't moved XX pixels\r\n        // and the input doesn't already have focus\r\n        if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\r\n            ev.preventDefault();\r\n            ev.stopPropagation();\r\n            // begin the input focus process\r\n            jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight);\r\n        }\r\n    };\r\n    componentEl.addEventListener('touchstart', touchStart, true);\r\n    componentEl.addEventListener('touchend', touchEnd, true);\r\n    return function () {\r\n        componentEl.removeEventListener('touchstart', touchStart, true);\r\n        componentEl.removeEventListener('touchend', touchEnd, true);\r\n    };\r\n};\r\nvar jsSetFocus = function (componentEl, inputEl, contentEl, keyboardHeight) {\r\n    var scrollData = getScrollData(componentEl, contentEl, keyboardHeight);\r\n    if (Math.abs(scrollData.scrollAmount) < 4) {\r\n        // the text input is in a safe position that doesn't\r\n        // require it to be scrolled into view, just set focus now\r\n        inputEl.focus();\r\n        return;\r\n    }\r\n    // temporarily move the focus to the focus holder so the browser\r\n    // doesn't freak out while it's trying to get the input in place\r\n    // at this point the native text input still does not have focus\r\n    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\r\n    inputEl.focus();\r\n    // scroll the input into place\r\n    contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration).then(function () {\r\n        // the scroll view is in the correct position now\r\n        // give the native text input focus\r\n        relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\r\n        // ensure this is the focused input\r\n        inputEl.focus();\r\n    });\r\n};\r\nvar hasPointerMoved = function (threshold, startCoord, endCoord) {\r\n    if (startCoord && endCoord) {\r\n        var deltaX = (startCoord.x - endCoord.x);\r\n        var deltaY = (startCoord.y - endCoord.y);\r\n        var distance = deltaX * deltaX + deltaY * deltaY;\r\n        return distance > (threshold * threshold);\r\n    }\r\n    return false;\r\n};\r\nvar PADDING_TIMER_KEY = '$ionPaddingTimer';\r\nvar enableScrollPadding = function (keyboardHeight) {\r\n    var doc = document;\r\n    var onFocusin = function (ev) {\r\n        setScrollPadding(ev.target, keyboardHeight);\r\n    };\r\n    var onFocusout = function (ev) {\r\n        setScrollPadding(ev.target, 0);\r\n    };\r\n    doc.addEventListener('focusin', onFocusin);\r\n    doc.addEventListener('focusout', onFocusout);\r\n    return function () {\r\n        doc.removeEventListener('focusin', onFocusin);\r\n        doc.removeEventListener('focusout', onFocusout);\r\n    };\r\n};\r\nvar setScrollPadding = function (input, keyboardHeight) {\r\n    if (input.tagName !== 'INPUT') {\r\n        return;\r\n    }\r\n    if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\r\n        return;\r\n    }\r\n    if (input.parentElement &&\r\n        input.parentElement.parentElement &&\r\n        input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\r\n        return;\r\n    }\r\n    var el = input.closest('ion-content');\r\n    if (el === null) {\r\n        return;\r\n    }\r\n    var timer = el[PADDING_TIMER_KEY];\r\n    if (timer) {\r\n        clearTimeout(timer);\r\n    }\r\n    if (keyboardHeight > 0) {\r\n        el.style.setProperty('--keyboard-offset', keyboardHeight + \"px\");\r\n    }\r\n    else {\r\n        el[PADDING_TIMER_KEY] = setTimeout(function () {\r\n            el.style.setProperty('--keyboard-offset', '0px');\r\n        }, 120);\r\n    }\r\n};\r\nvar INPUT_BLURRING = true;\r\nvar SCROLL_PADDING = true;\r\nvar startInputShims = function (config) {\r\n    var doc = document;\r\n    var keyboardHeight = config.getNumber('keyboardHeight', 290);\r\n    var scrollAssist = config.getBoolean('scrollAssist', true);\r\n    var hideCaret = config.getBoolean('hideCaretOnScroll', true);\r\n    var inputBlurring = config.getBoolean('inputBlurring', true);\r\n    var scrollPadding = config.getBoolean('scrollPadding', true);\r\n    var inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\r\n    var hideCaretMap = new WeakMap();\r\n    var scrollAssistMap = new WeakMap();\r\n    var registerInput = function (componentEl) {\r\n        var inputEl = (componentEl.shadowRoot || componentEl).querySelector('input') || (componentEl.shadowRoot || componentEl).querySelector('textarea');\r\n        var scrollEl = componentEl.closest('ion-content');\r\n        if (!inputEl) {\r\n            return;\r\n        }\r\n        if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\r\n            var rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\r\n            hideCaretMap.set(componentEl, rmFn);\r\n        }\r\n        if (!!scrollEl && scrollAssist && !scrollAssistMap.has(componentEl)) {\r\n            var rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, keyboardHeight);\r\n            scrollAssistMap.set(componentEl, rmFn);\r\n        }\r\n    };\r\n    var unregisterInput = function (componentEl) {\r\n        if (hideCaret) {\r\n            var fn = hideCaretMap.get(componentEl);\r\n            if (fn) {\r\n                fn();\r\n            }\r\n            hideCaretMap.delete(componentEl);\r\n        }\r\n        if (scrollAssist) {\r\n            var fn = scrollAssistMap.get(componentEl);\r\n            if (fn) {\r\n                fn();\r\n            }\r\n            scrollAssistMap.delete(componentEl);\r\n        }\r\n    };\r\n    if (inputBlurring && INPUT_BLURRING) {\r\n        enableInputBlurring();\r\n    }\r\n    if (scrollPadding && SCROLL_PADDING) {\r\n        enableScrollPadding(keyboardHeight);\r\n    }\r\n    // Input might be already loaded in the DOM before ion-device-hacks did.\r\n    // At this point we need to look for all of the inputs not registered yet\r\n    // and register them.\r\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\r\n        var input = inputs_1[_i];\r\n        registerInput(input);\r\n    }\r\n    doc.addEventListener('ionInputDidLoad', (function (ev) {\r\n        registerInput(ev.detail);\r\n    }));\r\n    doc.addEventListener('ionInputDidUnload', (function (ev) {\r\n        unregisterInput(ev.detail);\r\n    }));\r\n};\r\nexport { startInputShims };\r\n"]},"metadata":{},"sourceType":"module"}